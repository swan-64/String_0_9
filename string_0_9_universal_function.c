/* Реализация ф-ций перевода строки в число
 * unsigned -- ф-ция strToUns(),
 * unsigned long -- ф-ция strToUnsL(,
 * unsigned long long -- ф-ция strToUnsLL()
 * int -- ф-ция strToInt(),
 * long -- ф-ция strToIntL(),
 * long long -- ф-ция strToIntLL() */

#include <stdio.h>
#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>

#define CLEAR system("cls")
/* Семейство беззнаковых ф-ций */
unsigned strToUns(const char * strEnter);
unsigned long strToUnsL(const char * strEnter);
unsigned long long strToUnsLL(const char * strEnter);
/* Семейство знаковых ф-ций */
int strToInt(const char * strEnter);
long strToIntL(const char * strEnter);
long long strToIntLL(const char * strEnter);
/* Ф-ция очистки стандарного буфера ввода stdin. Используется для большей
 * кроссплатформенности */
void clean_stdin(void);
/* Ф-ция принимает код ошибки и ключ для выбора активного типа (это два
 * обязательных параметра вариадической ф-ции), после чего выводит
 * соответствующее активной ошибке сообщение. В некоторых вызовах ф-ции
 * используются необязательные параметры, для передачи дополнительной
 * информации.
 * Ф-ция возвращает код ошибки, сообщение о которой она выводила */
int print_usr_input_and_err_msg(int err_code, const char *type_name, ...);

int main(void)
{
    unsigned uNum = 0;
    unsigned long ulNum = 0;
    unsigned long long ullNum = 0;
    int iNum = 0;
    long lNum = 0;
    long long llNum = 0;

    char strW[] = "Введите длину корабля в метрах";

    uNum = strToUns(strW);
    ulNum = strToUnsL(strW);
    ullNum = strToUnsLL(strW);
    iNum = strToInt(strW);
    lNum = strToIntL(strW);
    llNum = strToIntLL(strW);

    printf(" strToUns()    Длина корабля в метрах равна %u\n", uNum);
    printf(" strToUnsL()   Длина корабля в метрах равна %lu\n", ulNum);
    printf(" strToUnsLL()  Длина корабля в метрах равна %llu\n", ullNum);
    printf(" strToInt()    Длина корабля в метрах равна %d\n", iNum);
    printf(" strToIntL()   Длина корабля в метрах равна %ld\n", lNum);
    printf(" strToIntLL()  Длина корабля в метрах равна %lld\n", llNum);

    return 0;
}

/* unsigned */
unsigned strToUns(const char * strEnter)
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    char str[12] = {0};                    /* Строка вводимая пользователем */
    register unsigned str_length = 0;      /* Длина строки str */
    register unsigned count_index = 0;     /* Индекс элемента в cтроке str */
    register char char_code = 0;           /* Код символа в таблице ASCII */
    register unsigned long long digit = 0; /* Хранит цифру перобразованную из
                                            * символа */
    register unsigned long long pow = 1;   /* Степень числа (для получения
                                            * разряда цифры digit в числе) */
    unsigned long long ull_result = 0;     /* Для записи итогового числа и
                                            * контороля переполнения */
    unsigned u_result = 0;                 /* Для итогового результата */
    char err = 0;                          /* Индикатор ошибки ввода */

    /* Начало главного цикл do while для ввода новой строки */
    do
    {
        /* Очистка экрана */
        CLEAR;
        /* Обнуление индикатора ошибки ввода err, для переключения в операторе
         * ? : на стартовый вывод на экран, если знач. переменной ull_result
         * соответствует диапазону unsigned, иначе оставляем err = -3, для
         * указания пользователю на ошибку */
        if (err != -3)
            err = 0;
        else
            print_usr_input_and_err_msg(-3, "U", str);
        /* Начало блока форматированного ввода строки str */
        do
        {
            /* Обнуление переменной итогового числа и контроля переполнения */
            ull_result = 0;
            /* Установка начального значения переменной отвечающей за степень
             * числа */
            pow = 1;
            /* Очистка (обнуление) символьной строки str для повторного ввода
             * пользователем */
            for (count_index = 0; count_index < 12 ; count_index++)
                str[count_index] = '\0';
            /* Блок приглашения для ввода пользователю и вывода дополнительной
             * информации для пользователя, в завсисмости от состояния
             * индикатора ошибки */
            (err == 0)
                ? print_usr_input_and_err_msg(0, "U", strEnter)
                : print_usr_input_and_err_msg(-10, "U");
            /* Присваиваем индиктору ошибки ввода значенение 0, т.к. без этого
             * корректный ввод будет также считаться ошибочным */
            err = 0;
            /* Индекс самого старшего элемена символьного массива str равен 10.
             * Для корректного ввода 10-и символов, 11-ый символ (с индексом
             * 10) отводится на символ '\n', который в дальнейшем
             * перезаписывается символом '\0' для определения конца строки */
            for (count_index = 0; count_index < 11 ; count_index++)
            {
                scanf("%c", &str[count_index]);
                /* -1 -- ошибка: недопустимый символ ' ' */
                if (str[count_index] == ' ')
                {
                    str[count_index] = '\0';
                    err = -1;
                    clean_stdin();
                    break;
                }
                /* Завершение блока ввода при вводе символа '\n' (<Enter>) */
                else if (str[count_index] == '\n')
                {
                    /* Устанавливаем '\0', чтобы не был присвоен символ '\n' */
                    str[count_index] = '\0';
                    CLEAR;
                    break;
                }
                /* Проверка корректности введенного пользователем символа */
                if (str[count_index] < '0' || str[count_index] > '9')
                {
                    /* Устанавливаем '\0', чтобы корректно работала обработка
                     * ошибок. Без присваивания текущему элементу '\0',
                     * программа обработает ошибку некорректно введённого
                     * символа, как ошибку превышения длины вводимой строки,
                     * в ситуации когда максимальное кол-во символов будут
                     * корректным (цифры), а следующий символ бедет некорретным
                     * (нецифровой символ), например: 4294967295h */
                    str[count_index] = '\0';
                    /* -2 -- ошибка: недопустимые символы (не цифры) */
                    err = -2;
                    clean_stdin();
                    break;
                }
            }
            /* Присваиваем str_length длину введённой пользователем строки */
            str_length = strlen(str);
            /* Проверка того, что 1-ый числовой символ не в пустой строке
             * не символ '0' (ввод числа с ведущим нулём запрещён) */
            if (str[0] == '0' && str_length != 1)
            {
                /* -5 -- ошибка: ведущий символом в числе является '0' */
                err = -5;
                /* Если введённых символов больше чем положено, то происходит
                 * очистка буфера стандартного потока ввода stdin */
                if (count_index > 10)
                {
                    clean_stdin();
                }
            }
            /* Проверка допустимой длины строки */
            else if (err == 0 && str_length > 10)
            {
                /* -6 -- ошибка: строка слишком длинная */
                err = -6;
                clean_stdin();
            }
            /* Проверка ввода пустой строки (пользователь нажал только
             * <Enter>) */
            else if (err == 0 && str[0] == 0)
            {
                /* -7 -- oшибка: введена пустая строка */
                err = -7;
            }
        }
        while (err < 0 && (CLEAR, print_usr_input_and_err_msg(err, "U")));
        /* Конец блока форматированного ввода строки str */
        /* Начало блока перевода строки str в число типа unsigned */
        for (count_index = str_length; count_index > 0; count_index--)
        {
            for (char_code = 48; char_code < 58; char_code++)
            {
                if (char_code == str[count_index-1])
                {
                    digit = char_code - 48;
                    break;
                }
            }
            ull_result += digit * pow;
            pow *= 10;
        }
        if (ull_result > 4294967295)
            /* -3 -- ошибка переполнения
             * (выход за пределы диапазона через верхнюю границу) */
            err = -3;
        else
            u_result = (unsigned)ull_result;
            /* Конец блока перевода строки str в число типа unsigned */
    }
    while (err == -3);
    /* Конец главного цикла do while для ввода новой строки */
    /* Возврат итогового результата работы ф-ции*/
    return u_result;
}

/* unsigned long */
unsigned long strToUnsL( const char * strEnter)
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    char str[12] = {0};                    /* Строка вводимая пользователем */
    register unsigned str_length = 0;      /* Длина строки str */
    register unsigned count_index = 0;     /* Индекс элемента в cтроке str */
    register char char_code = 0;           /* Код символа в таблице ASCII */
    register unsigned long long digit = 0; /* Хранит цифру перобразованную из
                                            * символа */
    register unsigned long long pow = 1;   /* Степень числа (для получения
                                            * разряда цифры digit в числе) */
    unsigned long long ull_result = 0;     /* Для записи итогового числа и
                                            * контороля переполнения */
    unsigned ul_result = 0;                /* Для итогового результата */
    char err = 0;                          /* Индикатор ошибки ввода */

    /* Начало главного цикл do while для ввода новой строки */
    do
    {
        /* Очистка экрана */
        CLEAR;
        /* Обнуление индикатора ошибки ввода err, для переключения в операторе
         * ? : на стартовый вывод на экран, если знач. переменной ull_result
         * соответствует диапазону unsigned long long, иначе оставляем
         * err = -3, для указания пользователю на ошибку */
        if (err != -3)
            err = 0;
        else
            print_usr_input_and_err_msg(-3, "UL", str);
        /* Начало блока форматированного ввода строки str */
        do
        {
            /* Обнуление переменной итогового числа и контроля переполнения */
            ull_result = 0;
            /* Установка начального значения переменной отвечающей за степень
             * числа */
            pow = 1;
            /* Очистка (обнуление) символьной строки str для повторного ввода
             * пользователем */
            for (count_index = 0; count_index < 12 ; count_index++)
                str[count_index] = '\0';
            /* Блок приглашения для ввода пользователю и вывода дополнительной
             * информации для пользователя, в завсисмости от состояния
             * индикатора ошибки */
            (err == 0)
                ? print_usr_input_and_err_msg(0, "UL", strEnter)
                : print_usr_input_and_err_msg(-10, "UL");
            /* Присваиваем индиктору ошибки ввода значенение 0, т.к. без этого
             * корректный ввод будет также считаться ошибочным */
            err = 0;
            /* Индекс самого старшего элемена символьного массива str равен 10.
             * Для корректного ввода 10-и символов, 11-ый символ (с индексом
             * 10) отводится на символ '\n', который в дальнейшем
             * перезаписывается символом '\0' для определения конца строки */
            for (count_index = 0; count_index < 11 ; count_index++)
            {
                scanf("%c", &str[count_index]);
                /* -1 -- ошибка: недопустимый символ ' ' */
                if (str[count_index] == ' ')
                {
                    str[count_index] = '\0';
                    err = -1;
                    clean_stdin();
                    break;
                }
                /* Завершение блока ввода при вводе символа '\n' (<Enter>) */
                else if (str[count_index] == '\n')
                {
                    /* Устанавливаем '\0', чтобы не был присвоен символ '\n' */
                    str[count_index] = '\0';
                    CLEAR;
                    break;
                }
                /* Проверка корректности введенного пользователем символа */
                if (str[count_index] < '0' || str[count_index] > '9')
                {
                    /* Устанавливаем '\0', чтобы корректно работала обработка
                     * ошибок. Без присваивания текущему элементу '\0',
                     * программа обработает ошибку некорректно введённого
                     * символа, как ошибку превышения длины вводимой строки,
                     * в ситуации когда максимальное кол-во символов будут
                     * корректным (цифры), а следующий символ бедет некорретным
                     * (нецифровой символ), например: 4294967295h */
                    str[count_index] = '\0';
                    /* -2 -- ошибка: недопустимые символы (не цифры) */
                    err = -2;
                    clean_stdin();
                    break;
                }
            }
            /* Присваиваем str_length длину введённой пользователем строки */
            str_length = strlen(str);
            /* Проверка того, что 1-ый числовой символ не в пустой строке
             * не символ '0' (ввод числа с ведущим нулём запрещён) */
            if (str[0] == '0' && str_length != 1)
            {
                /* -5 -- ошибка: ведущий символом в числе является '0' */
                err = -5;
                /* Если введённых символов больше чем положено, то происходит
                 * очистка буфера стандартного потока ввода stdin */
                if (count_index > 10)
                {
                    clean_stdin();
                }
            }
            /* Проверка допустимой длины строки */
            else if (err == 0 && str_length > 10)
            {
                /* -6 -- ошибка: строка слишком длинная */
                err = -6;
                clean_stdin();
            }
            /* Проверка ввода пустой строки (пользователь нажал только
             * <Enter>) */
            else if (err == 0 && str[0] == 0)
            {
                /* -7 -- oшибка: введена пустая строка */
                err = -7;
            }
        }
        while (err < 0 && (CLEAR, print_usr_input_and_err_msg(err, "UL")));
        /* Конец блока форматированного ввода строки str */
        /* Начало блока перевода строки str в число типа unsigned */
        for (count_index = str_length; count_index > 0; count_index--)
        {
            for (char_code = 48; char_code < 58; char_code++)
            {
                if (char_code == str[count_index-1])
                {
                    digit = char_code - 48;
                    break;
                }
            }
            ull_result += digit * pow;
            pow *= 10;
        }
        if (ull_result > 4294967295)
            /* -3 -- ошибка переполнения
             * (выход за пределы диапазона через верхнюю границу) */
            err = -3;
        else
            ul_result = (unsigned long)ull_result;
            /* Конец блока перевода строки str в число типа unsigned */
    }
    while (err == -3);
    /* Конец главного цикла do while для ввода новой строки */
    /* Возврат итогового результата работы ф-ции*/
    return ul_result;
}

/* unsigned long long */
unsigned long long strToUnsLL( const char * strEnter)
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    char str[22] = {0};                    /* Строка вводимая пользователем */
    register unsigned str_length = 0;      /* Длина строки str */
    register unsigned count_index = 0;     /* Индекс элемента в cтроке str */
    register char char_code = 0;           /* Код символа в таблице ASCII */
    register unsigned long long digit = 0; /* Хранит цифру перобразованную из
                                            * символа */
    register unsigned long long pow = 1;   /* Степень числа (для получения
                                            * разряда цифры digit в числе) */
    unsigned long long ull_result = 0;     /* Для итогового числа */
    unsigned long long ull_part1_num = 0;  /* Для хранения 1-ой части числа
                                            * после перевода символов
                                            * str[0] - str[9] */
    unsigned long long ull_part2_num = 0;  /* Для хранения 2-ой части числа
                                            * после перевода символов
                                            * str[10]-str[19] */
    char err = 0;                          /* Индикатор ошибки ввода */

    /* Начало главного цикл do while для ввода новой строки */
    do
    {
        /* Очистка экрана */
        CLEAR;
        /* Обнуление индикатора ошибки ввода err, для переключения в операторе
         * ? : на стартовый вывод на экран, если знач. переменной ull_result
         * соответствует диапазону unsigned long long, иначе оставляем
         * err = -3, для указания пользователю на ошибку */
        if (err != -3)
            err = 0;
        else
            print_usr_input_and_err_msg(-3, "ULL", str);
        /* Начало блока форматированного ввода строки str */
        do
        {
            /* Обнуление переменной итогового числа и контроля переполнения,
             * и переменных для хранения 1-ой и 2-ой частей итогового
             * числа */
            ull_result = ull_part1_num = ull_part2_num = 0;
            /* Установка начального значения переменной отвечающей за степень
             * числа */
            pow = 1;
            /* Очистка (обнуление) символьной строки str для повторного ввода
             * пользователем */
            for (count_index = 0; count_index < 22 ; count_index++)
                str[count_index] = '\0';
            /* Блок приглашения для ввода пользователю и вывода дополнительной
             * информации для пользователя, в завсисмости от состояния
             * индикатора ошибки */
            (err == 0)
                ? print_usr_input_and_err_msg(0, "ULL", strEnter)
                : print_usr_input_and_err_msg(-10, "ULL");
            /* Присваиваем индиктору ошибки ввода значенение 0, т.к. без этого
             * корректный ввод будет также считаться ошибочным */
            err = 0;
            /* Индекс самого старшего элемена символьного массива str равен 20.
             * Для корректного ввода 20-и символов, 21-ый символ (с индексом
             * 20) отводится на символ '\n', который в дальнейшем
             * перезаписывается символом '\0' для определения конца строки */
            for (count_index = 0; count_index < 21 ; count_index++)
            {
                scanf("%c", &str[count_index]);
                /* -1 -- ошибка: недопустимый символ ' ' */
                if (str[count_index] == ' ')
                {
                    str[count_index] = '\0';
                    err = -1;
                    clean_stdin();
                    break;
                }
                /* Завершение блока ввода при вводе символа '\n' (<Enter>) */
                else if (str[count_index] == '\n')
                {
                    /* Устанавливаем '\0', чтобы не был присвоен символ '\n' */
                    str[count_index] = '\0';
                    CLEAR;
                    break;
                }
                /* Проверка корректности введенного пользователем символа */
                if (str[count_index] < '0' || str[count_index] > '9')
                {
                    /* Устанавливаем '\0', чтобы корректно работала обработка
                     * ошибок. Без присваивания текущему элементу '\0',
                     * программа обработает ошибку некорректно введённого
                     * символа, как ошибку превышения длины вводимой строки,
                     * в ситуации когда максимальное кол-во символов будут
                     * корректным (цифры), а следующий символ бедет некорретным
                     * (нецифровой символ), например: 18446744073709551615h */
                    str[count_index] = '\0';
                    /* -2 -- ошибка: недопустимые символы (не цифры) */
                    err = -2;
                    clean_stdin();
                    break;
                }
            }
            /* Присваиваем str_length длину введённой пользователем строки */
            str_length = strlen(str);
            /* Проверка того, что 1-ый числовой символ не в пустой строке
             * не символ '0' (ввод числа с ведущим нулём запрещён) */
            if (str[0] == '0' && str_length != 1)
            {
                /* -5 -- ошибка: ведущий символом в числе является '0' */
                err = -5;
                /* Если введённых символов больше чем положено, то происходит
                 * очистка буфера стандартного потока ввода stdin */
                if (count_index > 20)
                {
                    clean_stdin();
                }
            }
            /* Проверка допустимой длины строки */
            else if (err == 0 && str_length > 20)
            {
                /* -6 -- ошибка: строка слишком длинная */
                err = -6;
                clean_stdin();
            }
            /* Проверка ввода пустой строки (пользователь нажал только
             * <Enter>) */
            else if (err == 0 && str[0] == 0)
            {
                /* -7 -- oшибка: введена пустая строка */
                err = -7;
            }
        }
        while (err < 0 && (CLEAR, print_usr_input_and_err_msg(err, "ULL")));
        /* Конец блока форматированного ввода строки str */
        /* Начало блока перевода строки str в число типа unsigned long long */
        /* Конвертирование строки длинной меньше 20-и символов */
        if (str_length < 20)
        {
           for (count_index = str_length; count_index > 0; count_index--)
            {
                for (char_code = 48; char_code < 58; char_code++)
                {
                    if (char_code == str[count_index-1])
                    {
                        digit = char_code - 48;
                        break;
                    }
                }
                ull_result += digit * pow;
                pow *= 10;
            }
        }
        /* Конвертирование строки длинной 20 символов */
        else
        {
            /* Конвертирование 1-ой части строки (первые 10 символов строки
             * str (str[0]-str[9])) */
            for (count_index = 10; count_index > 0; count_index--)
            {
                for (char_code = 48; char_code < 58; char_code++)
                {
                    if (char_code == str[count_index-1])
                    {
                        digit = char_code - 48;
                        break;
                    }
                }
                ull_part1_num += digit * pow;
                pow *= 10;
            }
            /* Проверка ull_part1_num */
            if (ull_part1_num > 1844674407ULL)
                /* Введенное в строке str число слишком большое и не помещается
                 * в диапазон unsigned long long */
                err = -3;
            /* Если число ull_part1_num <= 1844674407, то осуществляется
             * конвертация 2-ой части строки str(str[10]-str[19]) */
            else
            {
                for(pow = 1, count_index = 20; count_index > 10; count_index--)
                {
                    for(char_code = 48; char_code < 58; char_code++)
                    {
                        if(char_code == str[count_index-1])
                        {
                            digit = char_code - 48;
                            break;
                        }
                    }
                    ull_part2_num += digit * pow;
                    pow *= 10;
                }
                if (ull_part1_num == 1844674407ULL
                    && ull_part2_num > 3709551615ULL)                {
                     /* Введенное в строке str число слишком большое и не
                      * помещается в диапазон unsigned long long */
                    err = -3;                }
                /* Формируетcя итоговое значение ull_result, которое возвращает
                 * ф-ция */
                else
                    ull_result = ull_part1_num * 10000000000 + ull_part2_num;
            }
        }
    }
    while (err == -3);
    /* Конец главного цикла do while для ввода новой строки */
    return ull_result;
}

/* int */
int strToInt(const char * strEnter)
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    char str[13] = {0};                    /* Строка вводимая пользователем */
    register unsigned str_length = 0;      /* Длина строки str */
    register unsigned count_index = 0;     /* Индекс элемента в cтроке str */
    register char char_code = 0;           /* Код символа в таблице ASCII */
    register unsigned long long digit = 0; /* Хранит цифру перобразованную из
                                            * символа */
    register unsigned long long pow = 1;   /* Степень числа (для получения
                                            * разряда цифры digit в числе) */
    unsigned long long ull_result = 0;     /* Для записи промежуточного
                                            * результата */
    int i_result = 0;                      /* Для итогового результата */
    char err = 0;                          /* Индикатор ошибки ввода */
    unsigned u_flag;                       /* u_flag = 0; -- конвертируется
                                            * положительное число и 0,
                                            * u_flag = 1; -- конвертируется
                                            * отрицательное число */

    /* Начало главного цикл do while для ввода новой строки */
    do
    {
        /* Очистка экрана */
        CLEAR;
        /* Обнуление индикатора ошибки ввода err, для переключения в операторе
         * ? : на стартовый вывод на экран, если знач. переменной ull_result
         * соответствует диапазону int, иначе оставляем err = -3 или
         * err = -4, для указания пользователю на ошибку */
        if (err != -3 && err != -4)
            err = 0;
        else
        {
            if (err == -3)
                print_usr_input_and_err_msg(-3, "I", str);
            else
                print_usr_input_and_err_msg(-4, "I", str);;
        }
        /* Начало блока форматированного ввода строки str */
        do
        {
            /* Обнуление переменной итогового числа и контроля переполнения */
            ull_result = 0;
            /* Установка начального значения переменной отвечающей за степень
             * числа */
            pow = 1;
            /* Очистка (обнуление) символьной строки str для повторного ввода
             * пользователем */
            for (count_index = 0; count_index < 13 ; count_index++)
                str[count_index] = '\0';
            /* Блок приглашения для ввода пользователю и вывода дополнительной
             * информации для пользователя, в завсисмости от состояния
             * индикатора ошибки */
            (err == 0)
                ? print_usr_input_and_err_msg(0, "I", strEnter)
                : print_usr_input_and_err_msg(-10, "I");
            /* Присваиваем индиктору ошибки ввода значенение 0, т.к. без этого
             * корректный ввод будет также считаться ошибочным */
            err = 0;
            /* В случае работы с отрицательным числом: индекс самого старшего
             * элемента символьного массива str равен 11.
             * Для корректного ввода 11-и символов, 12-ый символ (с индексом
             * 11) отводится на символ '\n', который в дальнейшем
             * перезаписывается символом '\0' для определения конца строки */
            for (count_index = 0; count_index < 12 ; count_index++)
            {
                scanf("%c", &str[count_index]);
                /* Если первый введёный символ - '-', то осуществляется переход
                 * к следующей итерации цикла */
                if (count_index == 0 && str[0] == '-')
                {
                    continue;
                }
                /* -1 -- ошибка: недопустимый символ ' ' */
                else if (str[count_index] == ' ')
                {
                    str[count_index] = '\0';
                    err = -1;
                    clean_stdin();
                    break;
                }
                /* Завершение блока ввода при вводе символа '\n' (<Enter>) */
                else if (str[count_index] == '\n')
                {
                    /* Устанавливаем '\0', чтобы не был присвоен символ '\n' */
                    str[count_index] = '\0';
                    CLEAR;
                    break;
                }
                /* Проверка корректности введенного пользователем символа */
                if (str[count_index] < '0' || str[count_index] > '9')
                {
                    /* Устанавливаем '\0', чтобы корректно работала обработка
                     * ошибок. Без присваивания текущему элементу '\0',
                     * программа обработает ошибку некорректно введённого
                     * символа, как ошибку превышения длины вводимой строки,
                     * в ситуации когда максимальное кол-во символов будут
                     * корректным (цифры), а следующий символ бедет некорретным
                     * (нецифровой символ), например: 4294967295h */
                    str[count_index] = '\0';
                    /* -2 -- ошибка: недопустимые символы (не цифры) */
                    err = -2;
                    clean_stdin();
                    break;
                }
            }
            /* Присваиваем str_length длину введённой пользователем строки */
            str_length = strlen(str);
            if (str[0] == '-' && str_length  == 1)
            {
                /* -8 -- ошибка: первый символ '-', а цифровая часть числа
                 * отсутствует */
                err = -8;
            }
            else if (str[0] == '-' && str[1] == '0')
            {
                /* -9 -- ошибка: первым цифровым символом отрицательного числа
                 * является символ '0' */
                err = -9;
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (str[0] == '0' && str_length != 1)
            {
                /* -5 -- ошибка: ведущий символом в числе является '0' */
                err = -5;
                /* Если введённых символов больше чем положено, то происходит
                 * очистка буфера стандартного потока ввода stdin */
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] != '-' && str_length > 10)
            {
                /* -6 -- ошибка: строка слишком длинная (положительное
                 * число) */
                err = -6;
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] == '-' && str_length > 11)
            {
                /* -6 -- ошибка: строка слишком длинная (отрицательное
                 * число) */
                err = -6;
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] == 0)
            {
                /* -7 -- oшибка: введена пустая строка */
                err = -7;
            }
        }
        /* Для ошибки с кодом -6 в ф-цию print_usr_input_and_err_msg()
         * передаётся также сформированная строка. Она используется для
         * определения знака числа, от которого зависит значение максимально
         * возможной длины вводимой строки, которое увидит пользователь при
         * выводе текста ошибки */
        while ((err == -6 && (CLEAR,
                              print_usr_input_and_err_msg(err, "I", str)))
               || (err < 0 && (CLEAR,
                               print_usr_input_and_err_msg(err, "I"))));
        /* Конец блока форматированного ввода строки str */
        /* Начало блока перевода строки str в число типа unsigned */
        /* Если в строке указано отрицательное число */
        if (str[0] == '-')
            u_flag = 1;
        /* Если в строке указано положительное число или 0 */
        else
            u_flag = 0;
        for (count_index = str_length; count_index > u_flag; count_index--)
        {
            for (char_code = 48; char_code < 58; char_code++)
            {
                if (char_code == str[count_index-1])
                {
                    digit = char_code - 48;
                    break;
                }
            }
            /* Результат без учёта знака (модуль)*/
            ull_result += digit * pow;
            pow *= 10;
        }
        /* Проверка для положительного числа или 0-я */
        if (str[0] != '-')
        {
            if (ull_result > 2147483647)
                /* -3 -- ошибка переполнения (выход за пределы диапазона через
                 * верхнюю границу) */
                err = -3;
            else
                i_result = (int)ull_result;
        }
        /* Проверка для отрицательного числа */
        else
        {
            if (ull_result > 2147483648)
                /* -4 -- ошибка переполнения (выход за пределы диапазона через
                 * нижнюю границу) */
                err = -4;
            else
                i_result = (int)(~ull_result + 1);
        }
    }
    while (err == -3 || err == -4);
    /* Конец главного цикла do while для ввода новой строки */
    return i_result;
}

/* long */
long strToIntL(const char * strEnter)
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    char str[13] = {0};                    /* Строка вводимая пользователем */
    register unsigned str_length = 0;      /* Длина строки str */
    register unsigned count_index = 0;     /* Индекс элемента в cтроке str */
    register char char_code = 0;           /* Код символа в таблице ASCII */
    register unsigned long long digit = 0; /* Хранит цифру перобразованную из
                                            * символа */
    register unsigned long long pow = 1;   /* Степень числа (для получения
                                            * разряда цифры digit в числе) */
    unsigned long long ull_result = 0;     /* Для записи промежуточного
                                            * результата */
    int l_result = 0;                      /* Для итогового результата */
    char err = 0;                          /* Индикатор ошибки ввода */
    unsigned u_flag;                       /* u_flag = 0; -- конвертируется
                                            * положительное число и 0,
                                            * u_flag = 1; -- конвертируется
                                            * отрицательное число */

    /* Начало главного цикл do while для ввода новой строки */
    do
    {
        /* Очистка экрана */
        CLEAR;
        /* Обнуление индикатора ошибки ввода err, для переключения в операторе
         * ? : на стартовый вывод на экран, если знач. переменной ull_result
         * соответствует диапазону long, иначе оставляем err = -3 или
         * err = -4, для указания пользователю на ошибку */
        if (err != -3 && err != -4)
            err = 0;
        else
        {
            if (err == -3)
                print_usr_input_and_err_msg(-3, "IL", str);
            else
                print_usr_input_and_err_msg(-4, "IL", str);
        }
        /* Начало блока форматированного ввода строки str */
        do
        {
            /* Обнуление переменной итогового числа и контроля переполнения */
            ull_result = 0;
            /* Установка начального значения переменной отвечающей за степень
             * числа */
            pow = 1;
            /* Очистка (обнуление) символьной строки str для повторного ввода
             * пользователем */
            for (count_index = 0; count_index < 13 ; count_index++)
                str[count_index] = '\0';
            /* Блок приглашения для ввода пользователю и вывода дополнительной
             * информации для пользователя, в завсисмости от состояния
             * индикатора ошибки */
            (err == 0)
                ? print_usr_input_and_err_msg(0, "IL", strEnter)
                : print_usr_input_and_err_msg(-10, "IL");
            /* Присваиваем индиктору ошибки ввода значенение 0, т.к. без этого
             * корректный ввод будет также считаться ошибочным */
            err = 0;
            /* В случае работы с отрицательным числом: индекс самого старшего
             * элемента символьного массива str равен 11.
             * Для корректного ввода 11-и символов, 12-ый символ (с индексом
             * 11) отводится на символ '\n', который в дальнейшем
             * перезаписывается символом '\0' для определения конца строки */
            for (count_index = 0; count_index < 12 ; count_index++)
            {
                scanf("%c", &str[count_index]);
                /* Если первый введёный символ - '-', то осуществляется переход
                 * к следующей итерации цикла */
                if (count_index == 0 && str[0] == '-')
                {
                    continue;
                }
                /* -1 -- ошибка: недопустимый символ ' ' */
                else if (str[count_index] == ' ')
                {
                    str[count_index] = '\0';
                    err = -1;
                    clean_stdin();
                    break;
                }
                /* Завершение блока ввода при вводе символа '\n' (<Enter>) */
                else if (str[count_index] == '\n')
                {
                    /* Устанавливаем '\0', чтобы не был присвоен символ '\n' */
                    str[count_index] = '\0';
                    CLEAR;
                    break;
                }
                /* Проверка корректности введенного пользователем символа */
                if (str[count_index] < '0' || str[count_index] > '9')
                {
                    /* Устанавливаем '\0', чтобы корректно работала обработка
                     * ошибок. Без присваивания текущему элементу '\0',
                     * программа обработает ошибку некорректно введённого
                     * символа, как ошибку превышения длины вводимой строки,
                     * в ситуации когда максимальное кол-во символов будут
                     * корректным (цифры), а следующий символ бедет некорретным
                     * (нецифровой символ), например: 4294967295h */
                    str[count_index] = '\0';
                    /* -2 -- ошибка: недопустимые символы (не цифры) */
                    err = -2;
                    clean_stdin();
                    break;
                }
            }
            /* Присваиваем str_length длину введённой пользователем строки */
            str_length = strlen(str);
            if (str[0] == '-' && str_length  == 1)
            {
                /* -8 -- ошибка: первый символ '-', а цифровая часть числа
                 * отсутствует */
                err = -8;
            }
            else if (str[0] == '-' && str[1] == '0')
            {
                /* -9 -- ошибка: первым цифровым символом отрицательного числа
                 * является символ '0' */
                err = -9;
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (str[0] == '0' && str_length != 1)
            {
                /* -5 -- ошибка: ведущий символом в числе является '0' */
                err = -5;
                /* Если введённых символов больше чем положено, то происходит
                 * очистка буфера стандартного потока ввода stdin */
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] != '-' && str_length > 10)
            {
                /* -6 -- ошибка: строка слишком длинная (положительное
                 * число) */
                err = -6;
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] == '-' && str_length > 11)
            {
                /* -6 -- ошибка: строка слишком длинная (отрицательное
                 * число) */
                err = -6;
                if (count_index > 11)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] == 0)
            {
                /* -7 -- oшибка: введена пустая строка */
                err = -7;
            }
        }
        /* Для ошибки с кодом -6 в ф-цию print_usr_input_and_err_msg()
         * передаётся также сформированная строка. Она используется для
         * определения знака числа, от которого зависит значение максимально
         * возможной длины вводимой строки, которое увидит пользователь при
         * выводе текста ошибки */
        while ((err == -6 && (CLEAR,
                              print_usr_input_and_err_msg(err, "IL", str)))
               || (err < 0 && (CLEAR,
                               print_usr_input_and_err_msg(err, "IL"))));
        /* Конец блока форматированного ввода строки str */
        /* Начало блока перевода строки str в число типа unsigned */
        /* Если в строке указано отрицательное число */
        if (str[0] == '-')
            u_flag = 1;
        /* Если в строке указано положительное число или 0 */
        else
            u_flag = 0;
        for (count_index = str_length; count_index > u_flag; count_index--)
        {
            for (char_code = 48; char_code < 58; char_code++)
            {
                if (char_code == str[count_index-1])
                {
                    digit = char_code - 48;
                    break;
                }
            }
            /* Результат без учёта знака (модуль)*/
            ull_result += digit * pow;
            pow *= 10;
        }
        /* Проверка для положительного числа или 0-я */
        if (str[0] != '-')
        {
            if (ull_result > 2147483647)
                /* -3 -- ошибка переполнения (выход за пределы диапазона через
                 * верхнюю границу) */
                err = -3;
            else
                l_result = (long)ull_result;
        }
        /* Проверка для отрицательного числа */
        else
        {
            if (ull_result > 2147483648)
                /* -4 -- ошибка переполнения (выход за пределы диапазона через
                 * нижнюю границу) */
                err = -4;
            else
                l_result = (long)(~ull_result + 1);
        }
    }
    while (err == -3 || err == -4);
    /* Конец главного цикла do while для ввода новой строки */
    return l_result;
}

/* long long */
long long strToIntLL(const char * strEnter)
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    char str[22] = {0};                    /* Строка вводимая пользователем */
    register unsigned str_length = 0;      /* Длина строки str */
    register unsigned count_index = 0;     /* Индекс элемента в cтроке str */
    register char char_code = 0;           /* Код символа в таблице ASCII */
    register unsigned long long digit = 0; /* Хранит цифру перобразованную из
                                            * символа */
    register unsigned long long pow = 1;   /* Степень числа (для получения
                                            * разряда цифры digit в числе) */
    unsigned long long ull_result = 0;     /* Для записи промежуточного
                                            * результата */
    long long ll_result;                   /* Для итогового числа */
    char err = 0;                          /* Индикатор ошибки ввода */
    unsigned u_flag;                       /* u_flag = 0; -- конвертируется
                                            * положительное число и 0,
                                            * u_flag = 1; -- конвертируется
                                            * отрицательное число */


    /* Начало главного цикл do while для ввода новой строки */
    do
    {
        /* Очистка экрана */
        CLEAR;
        /* Обнуление индикатора ошибки ввода err, для переключения в операторе
         * ? : на стартовый вывод на экран, если знач. переменной ull_result
         * соответствует диапазону unsigned long long, иначе оставляем
         * err = -3, для указания пользователю на ошибку */
        if (err != -3 && err != -4)
            err = 0;
        else
        {
            if (err == -3)
                print_usr_input_and_err_msg(-3, "ILL", str);
            else
                print_usr_input_and_err_msg(-4, "ILL", str);
        }
        /* Начало блока форматированного ввода строки str */
        do
        {
            /* Обнуление переменной итогового числа, перменной промежуточного
             * результата и переменных для хранения 1-ой и 2-ой частей
             * итогового числа */
            ll_result = ull_result = 0;
            /* Установка начального значения переменной отвечающей за степень
             * числа */
            pow = 1;
            /* Очистка (обнуление) символьной строки str для повторного ввода
             * пользователем */
            for (count_index = 0; count_index < 22 ; count_index++)
                str[count_index] = '\0';
            /* Блок приглашения для ввода пользователю и вывода дополнительной
             * информации для пользователя, в завсисмости от состояния
             * индикатора ошибки */
            (err == 0)
                ? print_usr_input_and_err_msg(0, "ILL", strEnter)
                : print_usr_input_and_err_msg(-10, "ILL");
            /* Присваиваем индиктору ошибки ввода значенение 0, т.к. без этого
             * корректный ввод будет также считаться ошибочным */
            err = 0;
            /* В случае работы с отрицательным числом: индекс самого старшего
             * элемена символьного массива str равен 21.
             * Для корректного ввода 21-ного символа, 22-ой символ (с индексом
             * 21) отводится на символ '\n', который в дальнейшем
             * перезаписывается символом '\0' для определения конца строки */
            for (count_index = 0; count_index < 21 ; count_index++) // было 20
            {
                scanf("%c", &str[count_index]);
                /* Если первый введёный символ - '-', то осуществляется переход
                 * к следующей итерации цикла */
                if (count_index == 0 && str[0] == '-')
                {
                    continue;
                }
                /* -1 -- ошибка: недопустимый символ ' ' */
                else if (str[count_index] == ' ')
                {
                    str[count_index] = '\0';
                    err = -1;
                    clean_stdin();
                    break;
                }
                /* Завершение блока ввода при вводе символа '\n' (<Enter>) */
                else if (str[count_index] == '\n')
                {
                    /* Устанавливаем '\0', чтобы не был присвоен символ '\n' */
                    str[count_index] = '\0';
                    CLEAR;
                    break;
                }
                /* Проверка корректности введенного пользователем символа */
                if (str[count_index] < '0' || str[count_index] > '9')
                {
                    /* Устанавливаем '\0', чтобы корректно работала обработка
                     * ошибок. Без присваивания текущему элементу '\0',
                     * программа обработает ошибку некорректно введённого
                     * символа, как ошибку превышения длины вводимой строки,
                     * в ситуации когда максимальное кол-во символов будут
                     * корректным (цифры), а следующий символ бедет некорретным
                     * (нецифровой символ), например: 9446744073709551615h */
                    str[count_index] = '\0';
                    /* -2 -- ошибка: недопустимые символы (не цифры) */
                    err = -2;
                    clean_stdin();
                    break;
                }
            }
            /* Присваиваем str_length длину введённой пользователем строки */
            str_length = strlen(str);
            /* Проверка того, что первым символом не введён символ '-' без
             * числовой части */
            if (str[0] == '-' && str_length  == 1)
            {
                /* -8 -- ошибка: первый символ '-', а цифровая часть числа
                 * отсутствует */
                err = -8;
            }
            else if (str[0] == '-' && str[1] == '0')
            {
                /* -9 -- ошибка: первым цифровым символом отрицательного числа
                 * является символ '0' */
                err = -9;
                if (count_index > 20)
                {
                    clean_stdin();
                }
            }
            else if (str[0] == '0' && str_length != 1)
            {
                /* -5 -- ошибка: ведущий символом в числе является '0' */
                err = -5;
                /* Если введённых символов больше чем положено, то происходит
                 * очистка буфера стандартного потока ввода stdin */
                if (count_index > 20)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] != '-' && str_length > 19)
            {
                /* -6 -- ошибка: строка слишком длинная (положительное
                 * число) */
                err = -6;
                if (count_index > 20)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] == '-' && str_length > 20)
            {
                /* -6 -- ошибка: строка слишком длинная (отрицательное
                 * число) */
                err = -6;
                if (count_index > 20)
                {
                    clean_stdin();
                }
            }
            else if (err == 0 && str[0] == 0)
            {
                /* -7 -- oшибка: введена пустая строка */
                err = -7;
            }
        }
        /* Для ошибки с кодом -6 в ф-цию print_usr_input_and_err_msg()
         * передаётся также сформированная строка. Она используется для
         * определения знака числа, от которого зависит значение максимально
         * возможной длины вводимой строки, которое увидит пользователь при
         * выводе текста ошибки */
        while ((err == -6 && (CLEAR,
                              print_usr_input_and_err_msg(err, "ILL", str)))
               || (err < 0 && (CLEAR,
                               print_usr_input_and_err_msg(err, "ILL"))));
        /* Конец блока форматированного ввода строки str */
        /* Начало блока перевода строки str в число типа unsigned long long */
        /* Конвертирование строки длинной меньше 20-и символов */
        /* Если в строке указано отрицательное число */
        if (str[0] == '-')
            u_flag = 1;
        /* Если в строке указано положительное число или 0 */
        else
            u_flag = 0;

        for (count_index = str_length; count_index > u_flag; count_index--)
        {
            for (char_code = 48; char_code < 58; char_code++)
            {
                if (char_code == str[count_index-1])
                {
                    digit = char_code - 48;
                    break;
                }
            }
            /* Результат без учёта знака (модуль) */
            ull_result += digit * pow;
            pow *= 10;
        }
        /* Проверка для положительного числа или 0-я */
        if (str[0] != '-')
        {
            if (ull_result > 9223372036854775807ULL)
                /* -3 -- ошибка переполнения (выход за пределы диапазона через
                 * верхнюю границу) */
                err = -3;
            else
                ll_result = (long long)ull_result;
        }
        /* Проверка для отрицательного числа */
        else
        {
            if (ull_result > 9223372036854775808ULL)
                /* -4 -- ошибка переполнения (выход за пределы диапазона через
                 * нижнюю границу) */
                err = -4;
            else
                ll_result = (long long)(~ull_result + 1);
        }
    }
    while (err == -3 || err == -4);
    /* Конец главного цикла do while для ввода новой строки */
    return ll_result;
}

/* Ф-ция очистки стандарного буфера ввода stdin. Используется для большей
 * кроссплатформенности */
void clean_stdin(void)
{
    int chr;

    while ((chr = getchar()) != '\n' && chr != EOF);
}

/* Ф-ция принимает код ошибки и ключ для выбора активного типа (это два
 * обязательных параметра вариадической ф-ции), после чего выводит
 * cообщение соответствующее активной ошибке. В некоторых вызовах ф-ции
 * используются необязательные параметры, для передачи дополнительной
 * информации.
 * Ф-ция возвращает код ошибки, сообщение о которой она выводила */
int print_usr_input_and_err_msg(int err_code, const char *type_name, ...)
{
/* Макрос для указания в тексте ошибки минимально и максимально допустимого
 значения */
#define PRINT_MIN_MAX(value)                                \
        printf(template_type, va_arg(ptr_arg, const char *), (value))
/* Макрос для создания текста ОБОБЩАЮЩЕЙ ошибки при повторном вводе строки
 * пользователем */
#define CREATE_MOD_ERR_TXT_3_AND_4_AND_10_AND_USR_TXT(num_err)     \
    memcpy(template_type, errors_text[-err_code],                  \
           strlen(errors_text[-err_code]) + 1);                    \
    strncat(template_type, format_spec_##num_err[current_type],    \
            strlen(format_spec_##num_err[current_type]) + 1);      \

/* Макрос CREATE_MOD_ERR_TXT_6 выполняет следующие действия:
 * 0. Дублирование кода ошибки;
 * 1. Поиск места вставки изменяемого текста по вхождению символа '[';
 * 2. Сохранение последней неизменяемой подстроки строки ошибки;
 * 3. Втсавка изменяемого текста;
 * 4. Cоздание итоговой строки ошибки */
#define CREATE_MOD_ERR_TXT_6(str, maxl)                             \
    max_len = (maxl);                                               \
    strncpy(modif_errors_text, errors_text[-err_code],              \
            strlen(errors_text[-err_code]) + 1);                    \
    ptr_insert = strchr(modif_errors_text, '[');                    \
    strncpy(temp_end, ptr_insert, strlen(ptr_insert) + 1);          \
    strncpy(ptr_insert, str, 30);                                   \
    strncat(modif_errors_text, temp_end, strlen(temp_end) + 1);

    va_list ptr_arg;        /* Для работ с необязательными аргументами ф-ции */
    /* Текст ошибок и инструкции для пользователя */
    char errors_text[][240] =                                       /* код */
                                                                   /* ошибки */
    {
        " [1-ый символом в строке не должен быть '0']\n"             /*  0 */
        " [диапазон:",
        "\n Вы использовали пробельный символ!\n",                   /* -1 */
        "\n Вы использовали недопустимые символы!\n",                /* -2 */
        "\n Введенное значение %s больше",                           /* -3 */
        "\n Введенное значение %s меньше",                           /* -4 */
        "\n Первым введённым Вами символом является \'0\'!\n",       /* -5 */
        "\n Вы ввели СЛИШКОМ ДЛИННУЮ строку\n"                       /* -6 */
        " [максимальная длина строки:\n %d символов!]\n",
        "\n Вы ввели пустую строку!\n",                              /* -7 */
        "\n Вы ввели знак \'-\' без цифровой части!\n",              /* -8 */
        "\n Первым цифровым символом отрицательного числа\n"
        " является символ \'0\' !\n",
        "\n Вы ввели некорректное значение,"                         /*-10 */
        " попробуйте ещё раз!\n"
        " [допустимые символы: 0...9]\n"
        " [1-ый символом в строке не должен быть '0']\n"
        " [диапазон:"
    };
    /* Максимальные и минимальные значения используемых типов */
    struct limits
    {
        unsigned long long ull_max;
        unsigned long long ull_min;
        long long          ill_max;
        long long          ill_min;
        unsigned long       ul_max;
        unsigned long       ul_min;
        unsigned             u_max;
        unsigned             u_min;
        long                il_max;
        long                il_min;
        int                  i_max;
        int                  i_min;
    } num_limit =
        {
            18446744073709551615ULL,
            0ULL,
            9223372036854775807LL,
            -9223372036854775807LL-1LL,
            4294967295UL,
            0UL,
            4294967295U,
            0U,
            2147483647L,
            -2147483647L-1L,
            2147483647,
            -2147483647-1
        };
    /* Для контроля корректности параметра отвечающего за выбор типа */
    const char types[][4] =
        {"U", "UL", "ULL", "I", "IL", "ILL"};
    /* Для создания форматной строки выбранного типа */
    const char format_spec_usr_input[][80] =
        {
            "\n************************ strToUns() *************************"
            "**********\n",
            "\n************************ strToUnsL() ************************"
            "**********\n",
            "\n************************ strToUnsLL() ***********************"
            "**********\n",
            "\n************************ strToInt() *************************"
            "**********\n",
            "\n************************ strToIntL() ************************"
            "**********\n",
            "\n************************ strToIntLL() ***********************"
            "**********\n"
        };
    const char format_spec_3_4[][10] =
        {
            " %u !\n", " %lu !\n", " %llu !\n",
            " %d !\n", " %ld !\n", " %lld !\n"
        };
    const char format_spec_10[][120] =
        {
           " от %u\n            до %u\n включительно]\n\n Поле ввода: ",
           " от %lu\n            до %lu\n включительно]\n\n Поле ввода: ",
           " от %llu\n            до %llu\n включительно]\n\n Поле ввода: ",
           " от %d\n            до  %d\n включительно]\n\n Поле ввода: ",
           " от %ld\n            до  %ld\n включительно]\n\n Поле ввода: ",
           " от %lld\n            до  %lld\n включительно]\n\n Поле ввода: "
        };
    /* Для удобной работы с выбранным типом (именнованные индексы) */
    enum types {u_integer, ul_integer , ull_integer, i_integer, il_integer,
        ill_integer};
    enum types current_type;   /* Выбранный тип */
    int max_len;               /* Максимальная длина вводимой строки для
                                * выбранного типа */
    char template_type[480];   /* Шаблон для указания корректного спецификатора
                                * в ф-циях ввода-вывода */
    register int count;        /* Счётчик для работы цикла */
    /* Переменные необходимые для изменения строки ошибки с кодом -6 и -10.
     * Строка ошибки меняется в зависимости от знака числа вводимого
     * пользователем */
    char modif_errors_text[240];
    char temp_end[80];
    char *ptr_insert;

    va_start(ptr_arg, type_name); /* Инициализация ptr_arg для работы с
                                   * необязательными аргументами ф-ции*/

    /* Установка типа с которым будет производиться дальнейшая работа */
    for (count = u_integer; count <= ill_integer; count++)
    {
        if (!strncmp(type_name, types[count], 4))
        {
            current_type = count;
            break;
        }
    }
    /* Если указан некорректный аргумент type_name, то производится аварийный
     * выход из программы */
    if (count > ill_integer)
    {
        fprintf(stderr, "Error: in function \"print_usr_input_and_err_msg()\":\n"
                " the incorrect argument \"type_name\"\n");
        exit(EXIT_FAILURE);
    }

    switch (err_code)
    {
    case -1 :
    case -2 :
    case -5 :
    case -7 :
    case -8 :
    case -9 :
        printf(errors_text[-err_code]);
        break;
    case -3 :
        /* Cоздание форматированной строки для выбранного типа.
         * template_type используется для вывода ошибки с кодом -3, которая
         * сообщает о том, что введённое значение больше допустимого диапазона
         * текщего выбранного типа */
        CREATE_MOD_ERR_TXT_3_AND_4_AND_10_AND_USR_TXT(3_4);
        /* Вывод ошибки в зависимости от выбранного текущего типа */
        switch (current_type)
        {
        case   u_integer :
            PRINT_MIN_MAX(num_limit.u_max);
            break;
        case  ul_integer :
            PRINT_MIN_MAX(num_limit.ul_max);
            break;
        case ull_integer :
            PRINT_MIN_MAX(num_limit.ull_max);
            break;
        case   i_integer :
            PRINT_MIN_MAX(num_limit.i_max);
            break;
        case  il_integer :
            PRINT_MIN_MAX(num_limit.il_max);
            break;
        case ill_integer :
            PRINT_MIN_MAX(num_limit.ill_max);
            break;
        }
        break;
    case -4:
        /* Cоздание форматированной строки для выбранного типа.
         * template_type используется для вывода ошибки с кодом -4, которая
         * сообщает о том, что введённое значение меньше допустимого диапазона
         * текщего выбранного типа */
        CREATE_MOD_ERR_TXT_3_AND_4_AND_10_AND_USR_TXT(3_4);
        switch (current_type)
        {
        case   i_integer :
            PRINT_MIN_MAX(num_limit.i_min);
            break;
        case  il_integer :
            PRINT_MIN_MAX(num_limit.il_min);
            break;
        case ill_integer :
            PRINT_MIN_MAX(num_limit.ill_min);
            break;
        }
        break;
    case -6:
         /* Установка максимальной длины вводимой строки для выбранного типа */
        switch (current_type)
        {
        case  u_integer :
        case ul_integer :
            max_len = 10;
            strncpy(modif_errors_text, errors_text[-err_code], 80);
            break;
        case ull_integer :
            max_len = 20;
            strncpy(modif_errors_text, errors_text[-err_code], 80);
            break;
        case   i_integer :
        case  il_integer :
            if (*va_arg(ptr_arg, const char *) != '-')
            {
                CREATE_MOD_ERR_TXT_6("для положительного числа\n ", 10);
            }
            else
            {
                CREATE_MOD_ERR_TXT_6("для отрицательного числа\n ", 11);
            }
            break;
        case ill_integer:
            if (*va_arg(ptr_arg, const char *) != '-')
            {
                CREATE_MOD_ERR_TXT_6("для положительного числа\n ", 19);
            }
            else
            {
                CREATE_MOD_ERR_TXT_6("для отрицательного числа\n ", 20);
            }
        break;
        }
        printf(modif_errors_text, max_len);
        break;
    /* Построение приглашения пользователю для ввода исходя из конкретного
     * текщего типа */
    case 0 :
        printf(format_spec_usr_input[current_type]);
        printf("\n Пожалуйста, %s\n [допустимые символы: 0...9]\n",
               va_arg(ptr_arg, const char *));
    case -10 :
        if (err_code)
            printf(format_spec_usr_input[current_type]);
        /* Построение строки ошибки исходя из конкретного текущего типа */
            CREATE_MOD_ERR_TXT_3_AND_4_AND_10_AND_USR_TXT(10);
        /* Печать ошибки  */
        switch (current_type)
        {
        case   u_integer :
            printf(template_type, num_limit.u_min, num_limit.u_max);
            break;
        case  ul_integer :
            printf(template_type, num_limit.ul_min, num_limit.ul_max);
            break;
        case ull_integer :
            printf(template_type, num_limit.ull_min, num_limit.ull_max);
            break;
        case   i_integer :
            printf(template_type, num_limit.i_min, num_limit.i_max);
            break;
        case  il_integer :
            printf(template_type, num_limit.il_min, num_limit.il_max);
            break;
        case ill_integer :
            printf(template_type, num_limit.ill_min, num_limit.ill_max);
            break;
        }
        break;
    default:
        printf(errors_text[0]);
        exit(EXIT_FAILURE);
        break;
        }
    va_end(ptr_arg);

    return err_code;
}
